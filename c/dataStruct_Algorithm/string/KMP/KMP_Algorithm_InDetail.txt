在实际的应用中，经常会遇到在某个目录字符串中，搜索是否包含另一个字符串，是否存在？
e.g.

Case-1:

           目标字符串 :   char;short;int;long;float;double
           另一字符串 :   ;

           如果存在，就把这个目标字符串,以 另外字符串为分界线， 分割成 n 块， 如上例中, 分别成 6 块

             1. char
             2. short
             3. int
             4. long
             5. float
             6. double


Case-2:

           目标字符串 :   I fuck U
           另一字符串 :   fuck

        如果存在，就把这个另一字符串, 用 xxxx 代替 ( 隐藏 显示 屏蔽词 ) 
        显示成  I xxxx U
        

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

下面用专业一点的术语来定义这2种字符串:

        在某一字符串中，                                      搜索另一字符串是否存在 ?

前者: 目标串 ( 或叫 搜索字符串 ) : target(search) string
                                                              后者: 模式串 : pattern string




先来看一个比较简单的例子吧 :

                 target string : adababce
                 pattern       : abc

--------------------------------------------------
Brute-Force (BF) : 
--------------------------------------------------

正常的做法，是把2个字符串从左到右排列，并把字符串的头部对齐，然后1个字符接1个字符取出，进行俩俩对比                 
直到pattern的最后一个字符也被取出并与 target 的对比完(而且是 匹配的状态, 结论: pattern   [是] target 的字串 )
或者target已经到最后一个字符，而 pattern 中还有未进行匹配的字符        ( 结论: pattern [不是] target 的子串 )

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Step-1 :
init:
i=0,j=0
                 0  1  2  3  4  5  6  7
                 i->i`
     target  :   a  d  a  b  a  b  c  e

                 0  1  2
     pattern :   a  b  c
                 j


    t[0] = p[0] ?  'a' == 'a' ?  => true  , then Do { ++i; ++j; }


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Step-2 :
                    
                 0  1  2  3  4  5  6  7
                    i(求值后不变)
     target  :   a  d  a  b  a  b  c  e

                 0  1  2
     pattern :   a  b  c
                j`<-j

    t[1] = p[1] ?  'd' == 'b' ?  => false , then Do { 
                                                      //    对齐位            i   j
                                                      // i = (i -j) + 1;   = (1 - 1) +1 = 1   , 相当于i，没有发生变化
                                                         i 回到最开始与 pattern 第1个字符对齐的位置的[下]一个位置; ( Why ? )

                                                      // i = 0;
                                                      j 回到 pattern 的头部;
                                                    }


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Step-3 :

                 0  1  2  3  4  5  6  7
                    i->i`
     target  :   a  d  a  b  a  b  c  e

                    0  1  2
     pattern :      a  b  c
                    j(求值后不变)

    t[1] = p[0] ?  'd' == 'a' ?  => false , then Do { 
                                                      //    对齐位            i   j
                                                      // i = (i -j) + 1;   = (1 - 0) +1 = 2   
                                                         i 回到最开始与 pattern 第1个字符对齐的位置的[下]一个位置; ( Why ? )

                                                      // i = 0;
                                                      j 回到 pattern 的头部;
                                                    }

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Step-4 :

                 0  1  2  3  4  5  6  7
                       i->i`
     target  :   a  d  a  b  a  b  c  e

                       0  1  2
     pattern :         a  b  c
                       j->j`

    t[2] = p[0] ?  'a' == 'a' ?  => true , then Do { ++i; ++j; } 


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Step-5 :

                 0  1  2  3  4  5  6  7
                          i->i`
     target  :   a  d  a  b  a  b  c  e

                       0  1  2
     pattern :         a  b  c
                          j->j`

    t[3] = p[1] ?  'b' == 'b' ?  => true , then Do { ++i; ++j; } 


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Step-6 :

                 0   1  2  3     4  5  6  7
                           i` <- i
     target  :   a   d  a  b     a  b  c  e

                        0  1     2
     pattern :          a  b     c
                        j` <---- j

    t[4] = p[2] ?  'a' == 'c' ? false  => { 
                                            //    对齐位            i   j
                                            // i = (i -j) + 1;   = (4 - 2) +1 = 3   
                                               i 回到最开始与 pattern 第1个字符对齐的位置的[下]一个位置; ( Why ? )

                                            // i = 0;
                                            j 回到 pattern 的头部;
                                          }

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Step-7 :
                 0  1  2  3  4  5  6  7
                          i->i` 
     target  :   a  d  a  b  a  b  c  e

                          0  1  2
     pattern :            a  b  c
                          j(求值后不变)

    t[3] = p[0] ?  'b' == 'a' ?  => false { 
                                             //    对齐位            i   j
                                             // i = (i -j) + 1;   = (3 - 0) +1 = 4
                                                i 回到最开始与 pattern 第1个字符对齐的位置的[下]一个位置; ( Why ? )

                                             // i = 0;
                                             j 回到 pattern 的头部;
                                          }

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Step-8 :

                 0  1  2  3  4  5  6  7
                             i->i`
     target  :   a  d  a  b  a  b  c  e

                             0  1  2
     pattern :               a  b  c
                             j->j`

    t[4] = p[0] ?  'a' == 'a' ?  => { ++i; ++j; } 


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Step-9 :

                 0  1  2  3  4  5  6  7
                                i->i`
     target  :   a  d  a  b  a  b  c  e

                             0  1  2
     pattern :               a  b  c
                                j->j`

    t[5] = p[1] ?  'b' == 'b' ?  => { ++i; ++j; } 


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Step-10 :

                 0  1  2  3  4  5  6  7
                                   i->i`
     target  :   a  d  a  b  a  b  c  e

                             0  1  2 (3)
     pattern :               a  b  c
                                   j->j`

    t[6] = p[2] ?  'c' == 'c' ?  => { ++i; ++j; } 


至此为止 : j 已经匹配到了 pattern 的最后一个字符的，下一位，越界了
因此，不再需要匹配了。直接返回结果 : 

    result-index = i - j = 7-3 = 4 
( target[4] ~ [6] , 正好与 pattern[0] ~ pattern[2] 完全匹配 , 因此返回 4 )


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Core Core Core : 

下面来回复 Why 处的问题 :
    为什么:  i 回到最开始与 pattern 第1个字符对齐的位置的[下]一个位置 ;
因为 需要在 target 中找到与 pattern 完整匹配的子串，
必须满足 : pattern 的首字母对齐 target 某一位置的字符 ， 并且pattern 中从后续 ~ 结尾的所有字符串，都与 target头部对齐的后续字符串 一一匹配 ， 才能完成1次 子串的 完整匹配过程
因此就很容易理解，这个表达式 :  
        i = (i - j) + 1;

i 表达从 target  中，与 pattern 某个字符进行匹配的 ， target 的下标
j 表达   pattern 中，与 target  某个字符进行匹配的 ， pattern的下标 
( 
   由于j :  从初始值 0 开始计数

同时, j的数值表示,在 此下标之前, 有j个字符已经与 target 进行了匹配，而且匹配成功  

如 : 
       j = 0 时, 有0个字符 ( [没有]任何的字符 ) ，已经与 target完成了匹配
       j = 2 时，表示 pattern[0] ~ pattern[1] 这2个字符已经 与 target 完成了匹配 ( 而且每一位都已经 匹配成功 )
       j = 5 时，表示 pattern[0] ~ pattern[4] 这5个字符已经 与 target 完成了匹配 ( 而且每一位都已经 匹配成功 )
       j = 8 时，表示 pattern[0] ~ pattern[7] 这8个字符已经 与 target 完成了匹配 ( 而且每一位都已经 匹配成功 )
)

因此 i - j ,就把开始头部对齐的指针头， 回溯到了 target 与 pattern之前头部对齐的位置
(i-j) + 1, 就是向后移动1位， 再开始新一轮的匹配
!!!! [[与此同时]] !!!!  j = 0 会到 pattern 的头部 ( Core Core Core )




----------------------------------------------------------------------------------------------------
KMP 算法
----------------------------------------------------------------------------------------------------
那么，有没有什么很快捷、高效的方法？
让 target 的指针 i 不回溯, 到之前与 pattern 头部对齐的下一位置
而只通过回溯 pattern 的指针j 到某一个特定的位置呢 ？

答案是 !!![肯定]!!! 的

还是拿刚刚的例子 :
target  : adababce
pattern : abc


前面的几个步骤都比较类似, 不再一一赘述:


在 Step-6 处 :

                 0  1  2  3  4  5  6  7
                             i
     target  :   a  d  a  b  a  b  c  e

                       0  1  2
     pattern :         a  b  c
                             j

 target[2~3] = "ab"
pattern[0~1] = "ab"

但当比较到最后一个字符时，'c' 与 'a' 失配了
如果用之前的做法， i 要移到到前面的[3]处 ( 指向 'b' ，而 pattern 指针又回到了 [0] 处 )

可以很明显看到 : 以下的比较是无效果的，肯定会失配的 ( Why )

adababce
   abc

因为，已经匹配的字符串  "ab" 中，a 与 b 是2个不同的字母，无需进行无意义的匹配动作
把 i 指针回溯到 已经匹配成功的 "ab" 的 'b' 处，再令j指针，回到 pattern的头部，是一种多此一举的匹配动作
( 这是基于 "ab" 是2个不相等的字母的原因，推出的结果 )



####################################################################################################
####################################################################################################
####################################################################################################
KMP

再看一个例子:
                      i
target:     babc123abc-abc123abcd
pattern:     abc123abcd
                      j



当 '-' 与 'd' 失配时，前面的 target的 'abc123abc' 与 pattern 'abc123abc' 是已经匹配成功的

                      i
target  : b|abc123abc|-abc123abcd
pattern :  |abc123abc|d
                      j

很明显: 可以看到，如果使用 BF 算法
让 i 回到头部对齐的下一位， j 回到 pattern 的头部,再进行匹配

可以看出 :
    pattern 中的头部字符      : 'a'
与   target 中的后续的5个字符 : 'b','c','1','2','3'     都匹配[失败]


直到 '3' 后 'a' 才会匹配[成功]
与此同时，target 的 'a'后面的 'bc' 也与 pattern 'a' 后面的 'bc' 匹配成功

                     i            
target  :  babc123abc-abc123abcd
pattern :         abc123abcd
                     j

那么，可能此时，你就会思考：
   能不能把 target "abc123abc" 中的后3个 "abc" 与 pattern 中的前3个 "abc" 对齐后， 继续进行匹配呢？

回答是[肯定]的!!! 同时，还可以继续得出一个很大胆的猜测 :

    不同时移动 i,j 指针 ，似乎只与 pattern 中的已经匹配的子串有关，与 target串 无关
因为部分匹配时， target 与 pattern 中的子串，已经匹配了。

当'c' 与 target 中的 某个字符匹配失败时, 前方的子串 与 target某一段的子串是完全一致的
下方用|         | 括起来
      |abc123abc|d

从中可以看到 abc123abc , 前3个字符 与 后3个字符是相等的

Core Core Core:
    这里就引入一个概念， 字符串的 < 公共 前/后缀 字符串 >


    abc123abc       前缀                                                          后缀                                                  前、后缀相等的配对              前、后缀相等时最长串的长度
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    a               无前缀                                                        无后缀                                                      无                              -1 ???

    ab              a                                                             b                                                           无                               0

    abc             a,ab                                                          c,bc                                                        无                               0

    abc1            a,ab,abc                                                      1,c1,bc1                                                    无                               0

    abc12           a,ab,abc,abc1                                                 2,12,c12,bc12                                               无                               0

    abc123          a,ab,abc,abc1,abc12                                           3,23,123,c123,bc123                                         无                               0

    abc123a         a,ab,abc,abc1,abc12,abc123                                    a,3a,23a,123a,c123a,bc123a                                  a                                1

    abc123ab        a,ab,abc,abc1,abc12,abc123,abc123a                            b,ab,3ab,23ab,123ab,c123ab,bc123ab                          ab                               2

    abc123abc       a,ab,abc,abc1,abc12,abc123,abc123a,abc123ab                   c,bc,abc,3abc,23abc,123abc,c123abc,bc123abc                 abc                              3



Core Core Core :
   因此，当 pattern 中有字符与 target 失配时，那么说明在失配之前的字符都是一一匹配成功的
失配时，就需要计算出,  失配前的子串中的最长相等的前、后缀串，使 target 的后缀串，与 pattern的前缀串对齐，再用 target 失配字符 与 相等前后缀串后面的那个字符进行比较
假定 前后缀相等(最长???)的的字符串长度是 k ( nextVal[j] = k  ), 那么 j 指针只要回溯到 pattern前缀串的后一位，就可以了。 i 指针不用移动 !!
因为 失配时 j 指向 'd', j = 9, 

          j = 9
      nextval[j]
    = nextval[9] 
    = 3

令 j 从 9 回溯到 3  ，即 pattern 串向右滑动 9-3 = 6 位(6个字符)


                      i
target    : babc123abc-abc123abcd
pattern-1 :  abc123abcd
                      j
pattern-2 :        abc123abcd


那么为什么是<最长>的相等前后缀的长度呢？
e.g.

              
         baaaaad
              -
          aaaad
              -
     
    失配时 "aaaa" 的前后缀情况如下

    aaaa
--------------------------------------------------
    a  a    1
--------------------------------------------------
    aa
      aa    2
--------------------------------------------------
    aaa
     aaa    3
--------------------------------------------------

相等的前后缀串有3组， 长度分别是1，2，3

取最短的长度 1, 匹配的过程如下
                                  
   baaaaad           baaaaad                   baaaaad                   baaaaad                     baaaaad                  baaaaad    
        -     =>          -          =>              -            =>           -            =>             -         =>              -             =>   从 baaaaad 中 没有找到 "aaaad"
    aaaad                aaaad                     aaaad                      aaaad                        aaaad                    aaaad 
        -                 -                          -                         -                           -                        -    


但是明明，就有完全匹配的子串

   baaaaad
     aaaad


因此，[不能]取[最短]的公共前后缀长度

那么: 取最短的长度 3, 匹配的过程如下
                                                                                                              
   baaaaad          baaaaad          baaaaad             baaaaad         baaaaad 
        -     =>         -    =>          -     =>             -    =>          -     =>   找到了
    aaaad            aaaad             aaaad               aaaad           aaaad 
        -                -                -                    -                - 



----------------------------------------------------------------------------------------------------
那么 : 如何 求 公共前后缀字符串 ( NextArray ) 数组 呢 ?

1.  abd345abc678abd345abc!
2.  abd345abc678abd345abd!
3.  abd345abc678abd345aba!
4.  abd345abc678abd345abw!


见 PowerPoint 文档 :  KMP_Animation.pptx 
