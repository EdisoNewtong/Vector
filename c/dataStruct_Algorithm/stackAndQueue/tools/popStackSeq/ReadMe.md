https://zhuanlan.zhihu.com/p/97619085

/********************************************************************************************************************************************

    问题 ： 

有 n 个元素序列 ， 分别是 ABCDEFG ...   , 对这些元素进行栈的操作，最终，当栈为空时，请问一共有多少种不同的输入序列
e.g.


----------------------------------------------------------------------------------------------------
    1个元素 A    : 那么栈的操作只有1种 : 

	    1.       A in --> A out :   因此出栈的序列也只有1种  A    

----------------------------------------------------------------------------------------------------
	2个元素 AB   : 那么栈的操作有以下2种 :

	    1.       A in --> A out --> B in  --> B out   :    AB
	    2.       A in --> B in  --> B out --> A out   :    BA


----------------------------------------------------------------------------------------------------
	3个元素 ABC   : 那么栈的操作有以下5种

	    1.       A in --> A out --> B in  --> B out --> C in   -->  C out  :     ABC
	    2.       A in --> A out --> B in  --> C in  --> C out  -->  B out  :     ACB
	    3.       A in --> B  in --> B out --> A out --> C in   -->  C out  :     BAC
	    4.       A in --> B  in --> C in  --> C out --> B out  -->  A out  :     CBA
	    5.       A in --> B  in --> B out --> C in  --> C out  -->  A out  :     BCA
	   
----------------------------------------------------------------------------------------------------


                n
总共有   :    C     /  (n+1)    种可能性
                2n


      n         (n+1)
=  C      -   C 
     2n         2n


第1个表达式表示 ： 在 2n 个槽中选中 n 个槽 ，向这些槽中填入n个 <入栈>的操作, 因此剩余的n个槽中只能填入 n个<出栈>操作，
<入栈> 与 <出栈> 是数量相等的, 但这其中有一些序列是<非法>的 栈 序列.
如: 
1. 出栈 
2. 入栈

<卡特兰>数


接下来让我们观察一下 n = 3 的一种出栈序列：+1, -1, -1, +1, -1, +1。序列<前三项之和>   小于 0，显然这是个非法的序列。
如果将 第1组 前缀和小于 0 的前缀，即前三项元素都进行取反，就会得到：-1, +1, +1, +1, -1, +1。此时有 (3+1) 个 +1 以及 (3-1) 个 -1。
因为这个小于 0 的前缀和必然是 -1，且 -1 比 +1 多一个，取反后，-1 比 +1 少一个，则 +1 变为 n + 1 个，且 -1 变为 n - 1 个。
进一步推广，对于 n 元素的每种非法出栈序列，都会对应一个含有 (n+1) 个 +1 以及 (n-1) 个 -1 的序列。

如何证明这两种序列是一一对应的?
假设非法序列为 A，
对应的序列为 B。

每个A只有一个"第一个前缀和小于 0 的前缀"，
所以每个A只能产生一个B。而每个B想要还原到A，就需要找到"第一个前缀和大于 0 的前缀"，显然 B 也只能产生一个 A。



每个 B 都有 (n+1) 个 +1 
       以及 (n-1) 个 -1，

                (n+1)
因此 B 的数量为C
                 2n

相当于在长度为 2n 的序列中找到(n+1)个位置存放 +1

                               (n+1)
相应的，非法序列的数量也就等于C
                                2n

						  n                                   n       (n+1)        n     /
因此出栈序列的总数量为 C       , 因此合法的出栈序列的数量为 C     -  C       =   C      /   (n+1)
                         2n                                  2n       2n          2n   /




2.2 括号序列

题目描述

n 对括号，则有多少种 “括号匹配” 的括号序列



思路:                                                           
                                                                n    /
左括号看成 +1，右括号看成 -1，那么就和上题的进出栈一样，共有  C     / (n+1)   种序列
                                                               2n  /


----------------------------------------------------------------------------------------------------



   这一过程 和 二叉树的结构极其地相似， 因为二叉树最多有2个结点 ， 而栈的操作也只有2种操作， 出栈/出栈
因此可以设计 一个二叉树的数据结构

这里约定:

    树的根结点一定是 Push 结点 , 树的叶子结点一定是 Pop 结点，同时，这一叶子结点也是 栈操作的 终结结点

       左子树为 Push 操作
	   右子树为 Pop  操作

l
********************************************************************************************************************************************/

