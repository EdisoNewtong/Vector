----------------------------------------------------------------------------------------------------
gen 程序用于生成多个测试用例的数组，用于测试 排序算法的正确性
----------------------------------------------------------------------------------------------------
// N 表示生成元素个数为N的所有排序关系不重复的数组， --bin表示以2进制格式写入文件<filename>
$ gen N    [--bin=<filename>]


二进制格式如下: 

The 1st byte ( ?xxx | xxxx ) will carry not only the infomation of array.size
But also store the big-endian / little-endian flag for reading the next filed which stored the TestCase Arrays' count

   big-endian    : ?=1
   little-endian : ?=0

The rest 7 bits to store the elements count for the following array :
|-----------------------------------|------------------------------|-------------------------------------
|                                   |                              |  ( Each element range : [0,255] so use 1 char to store a number )
|-----------------------------------|------------------------------|-------------------------------------|
| How many elements in the array    | How many TestCase Array(s)   |  Array Content                      |        
|-----------------------------------|------------------------------|-------------------------------------|
|             N                     |   Array count  M             | [ary-1] [ary-2] [ary-3] ... [ary-M] |
|-----------------------------------|------------------------------|-------------------------------------|
|           1 byte                  |   4 bytes (int)              |  Use 1 char to store each element   |
|-----------------------------------|------------------------------|-------------------------------------|


例如有 256 ( 0x100 )  个数组，每个数组中有 10 (0x0A) 个元素 : 
******************************
*****     Big-Endian     *****
******************************
------------------------------------------------------------------------------------------------------------------------
|   10     |      256            |   TestCase Array [0]           ,  TestCase Array[1]    ...    TestCase Array[255]   |
------------------------------------------------------------------------------------------------------------------------
| 1 byte   |    4 bytes          |  [0]   [1]   [2]  ...    [9]  ,     ...                                             |
------------------------------------------------------------------------------------------------------------------------
|   0x8A   | 0x00 0x00 0x01 0x00 | 0x??, 0x??, 0x??, ... ,  0x?? ,  ( Rest 255 array(s) ... totally 255*10 bytes) ... |
------------------------------------------------------------------------------------------------------------------------

******************************
*****   Little-Endian    *****
******************************
------------------------------------------------------------------------------------------------------------------------
|   10     |      256            |   TestCase Array [0]           ,  TestCase Array[1]    ...    TestCase Array[255]   |
------------------------------------------------------------------------------------------------------------------------
| 1 byte   |    4 bytes          |  [0]   [1]   [2]  ...    [9]  ,     ...                                             |
------------------------------------------------------------------------------------------------------------------------
|   0x0A   | 0x00 0x01 0x00 0x00 | 0x??, 0x??, 0x??, ... ,  0x?? ,  ( Rest 255 array(s) ... totally 255*10 bytes)      |
------------------------------------------------------------------------------------------------------------------------
                                                                                                                            256个1         256个2                       256个256                                                          
    为什么， 把数组的元素(1 unsignec char), 范围设置在 [0,255]  之间，因为一个包含 256个元素的数组，如果每一个元素都存在 [0,255] 种可能的话 ( 即[1,1,1, ... , 1],  [2,2,2, ... , 2], ... , [256,256,256, ... , 256] 都是一种测试用例的数组 )
那么，数组的种类会有 256^256 种可能性，已经是一个非常大的测试集合了，已经能够覆盖所有的排序算法正确性的测试 
另外，为了针对，生成测试用例的程序 与 读取测试用例的程序(主要是读取一个 > 1 byte 的 int 类型的数据时, 才需要考虑字节序的差异情况 )
所在的计算机架构类型不相同，需要考虑 Little-Endian / Big-Endian 的移植性的问题
    目前，把2个数组元素合并在1个byte的内存中，第1个元素放在前4个bits, 第2个元素放在后4个bits处。这样可以用于节约磁盘空间。





如何验证一个自己写的排序算法的正确性呢，需要一些满足某些条件的若干个数组，来进行验证

那么这些数组，是否有相同类型的呢？
例如: 
对于一个包含4个元素的数组   [1,1,1,1]   [2,2,2,2]  [3,3,3,3] [4,4,4,4]  [10,10,10,10] 
应用相同的排序算法，得到的结果应该是一致的，这是因为所有的元素都相等

同理 [1,2,3,4]   [2,3,4,5]  [20,40,60,80]   [1, 7, 100, 345 ]
应用相同的排序算法，得到的结果应该是一致的，这是因为数组中的元素已经按照升序排列了


同理 [4,3,2,1]  [5,4,3,2]  [80,60,40,20]   [345,100,7,1]
应用相同的排序算法，得到的结果应该是一致的，这是因为数组中的元素已经按照降序排列了


****************************************************************************************************
****************************************************************************************************
****************************************************************************************************
同理 [4,2,1,3]   [43,25,17,36]
应用相同的排序算法，得到的结果应该是一致的，这是因为数组中的元素已经按照降序排列了

对于这2个数组中，各个不同位置上的元素，与剩余的位置的元素进行 大小比较，得到如下结论
___________________________________________________________________________________________________________________
             Right Comparand |    4        |      2      |      1      |      3      |
----------|------------------|-------------|-------------|-------------|-------------|--------------------------------------
          |   4              |    Eq       |  4 > 2      |  4 > 1      |  4 > 3      |                                         
          |------------------|-------------|-------------|-------------|-------------|--------------------------------------
 Left     |   2              | N/A(2 < 4)  |     Eq      |  2 > 1      |  2 < 3      |                                         
          |------------------|-------------|-------------|-------------|-------------|--------------------------------------
Comparand |   1              | N/A(1 < 4)  | N/A(1 < 2)  |     Eq      |  1 < 3      |                                         
          |------------------|-------------|-------------|-------------|-------------|--------------------------------------
          |   3              | N/A(3 < 4)  | N/A(3 > 2)  | N/A(3 > 1)  |      Eq     |                                         
----------|------------------|-------------|-------------|-------------|-------------|--------------------------------------
        


N/A 处需要进行一些说明，由于下列的 3个 关系比较运算符，都具有 对称性 即 ( a > b  <==>  b < a ) 
1.      '<'   即 ( a < b   <==>  b > a ) 
2.      '>'   即 ( a > b   <==>  b < a ) 
3.     '=='   即 ( a == b  <==>  b == a ) 


--------------------------------------------------
Array :  [4,2,1,3]
--------------------------------------------------
1st turn : [0] 与  EQ,    [1],  [2],   [3] 进行比较 
2nd turn : [1] 与 N/A,     EQ,  [2],   [3] 进行比较 ( 因为 [1] 与 [0]     , 已经在 1st        轮中，完成了比较，可以通过 关系比较运算符的 对称性，可到结果
3rd turn : [2] 与 N/A,    N/A,   EQ,   [3] 进行比较 ( 因为 [2] 与 [0],[1] , 已经在 1st && 2nd 轮中，完成了比较，可以通过 关系比较运算符的 对称性，可到结果


最终结论:
          对于 n 个元素的数组，如果各个元素之前的关系一致，那么应用同一算法后的，结果也是一致的 ( 无论排序后的数组是否真的满足 升/降序的需要，他们在程序运行时的行为应该都是一致的 )
关系比较运算符的数量大概有以下的规则：
n = 2 时 ：  [ a, b    ]   ( a > b     /     a==b    /     a < b  )  , 一共3种可能性
n = 3 时 ：  [ a, b, c ]   按n=2时的情况，推则 (a op b   ,  a op c)  , 理论上: 一共 3 * 3 * 3 = 27 种可能性
                                               (b op c)

             但是实际情况，却 < 27 种可能性， 因为如果 ( a == b , a == c ) 
                                              那么必然能推导出 b == c ( b < c   or  b < c    永远不成立 )

                                              另外一个反例 （ a < b,   a > c ) ==>      ( c < a < b ) , 
                                              即 a 这是这3个数中，排在中间大小的数， c 最小， b 最大
                                              那么必然能推导出 b > c ( b = c   or  b < c    永远不成立 )

            实际共有13种  ( 可能需要 排列组合 公式，对总共的可能性，求一个通项公式， 目前我还没有研究出来 ) 

noramlly considerate : 27 possibilities (3*3*3) :

[(a op b    , a op c), (b op c)]
------------------------------------------------------------------------------------------------------------------------------------
01. [  >    ,   >   ,     >   ]   1. Valid [3,2,1]
02. [  >    ,   >   ,     ==  ]   2. Valid [3,2,2]
03. [  >    ,   >   ,     <   ]   3. Valid [3,1,2]
04. [  >    ,   ==  ,     >   ] Impossible (a>b, a==c) ==> c>b but  here b>c
05. [  >    ,   ==  ,     ==  ] Impossible if 2 of 3 is == , the rest 1 of 3 must be ==
06. [  >    ,   ==  ,     <   ]   4. Valid [3,2,3]
07. [  >    ,   <   ,     >   ] Impossible (a>b, a<c) ==>  (b<a<c) ==> b < c , but here  b >  c
08. [  >    ,   <   ,     ==  ] Impossible (a>b, a<c) ==>  (b<a<c) ==> b < c , but here  b == c
09. [  >    ,   <   ,     <   ]   5. Valid [2,1,3]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
10. [  ==    ,   >   ,     >  ]   6. Valid [2,2,3]
11. [  ==    ,   >   ,     == ] Impossible (a==b,a>c) ==> b>c , but here b == c
12. [  ==    ,   >   ,     <  ] Impossible (a==b,a>c) ==> b>c , but here b  < c
13. [  ==    ,   ==  ,     >  ] Impossible if 2 of 3 is == , the rest 1 of 3 must be ==
14. [  ==    ,   ==  ,     == ]   7. Valid [1,1,1]
15. [  ==    ,   ==  ,     <  ] Impossible if 2 of 3 is == , the rest 1 of 3 must be ==
16. [  ==    ,   <   ,     >  ] Impossible (a==b,a<c) ==> b<c , but here b > c
17. [  ==    ,   <   ,     == ] Impossible if 2 of 3 is == , the rest 1 of 3 must be ==
18. [  ==    ,   <   ,     <  ]   8. Valid [1,1,2]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
19. [  <    ,   >   ,     >   ]   9. Valid [2,3,1]
20. [  <    ,   >   ,     ==  ] Impossible (a<b,a>c) ==> (c<a<b) ==> c < b , but here  b == c
21. [  <    ,   >   ,     <   ] Impossible (a<b,a>c) ==> (c<a<b) ==> c < b , but here  b  < c
22. [  <    ,   ==  ,     >   ]   10. Valid [2,3,2]
23. [  <    ,   ==  ,     ==  ] Impossible if 2 of 3 is == , the rest 1 of 3 must be ==
24. [  <    ,   ==  ,     <   ] Impossible (a<b, a==c) ==> (b>c) , but here b < c
25. [  <    ,   <   ,     >   ]   11. Valid [1,3,2]
26. [  <    ,   <   ,     ==  ]   12. Valid [1,2,2]
27. [  <    ,   <   ,     <   ]   13. Valid [1,2,3]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


