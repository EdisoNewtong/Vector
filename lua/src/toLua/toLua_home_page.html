<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="GENERATOR" CONTENT="Microsoft FrontPage 4.0">
   <META NAME="Author" CONTENT="Waldemar Celes">
   <TITLE>toLua home page</TITLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#FF0000">

<H1>
<IMG SRC="logo.gif" HEIGHT=128 WIDTH=128>tolua - <I>accessing C/C++ code
from Lua</I></H1>

<H1>

</h1>

<HR ALIGN=LEFT SIZE=5 WIDTH="100%">
<B>tolua</B> is a tool that greatly simplifies the integration of C/C++
code with <A HREF="http://www.tecgraf.puc-rio.br/lua">Lua</A>. Based on
a <I>cleaned</I> <I>header file</I>, <B>tolua</B> automatically generates
the binding code to access C/C++ features from Lua. Using Lua API and tag
method facilities, <B>tolua </B>maps C/C++ constants, external variables,
functions, classes, and methods to Lua.
<P>This manual is for <B>tolua </B> version 3<I>.2</I> and is implemented upon Lua
3.2. Several improvements have been made since version 3.0 (see
<A HREF="#changes-v30">Changes
since v3.0</A> for details).
<P>The sections below describe how to use <B>tolua</B>. Please <A HREF="mailto:celes@tecgraf.puc-rio.br">send
me</A> bug reports, suggestions, and comments.
<UL>
<LI>
Shortcuts:</LI>

<UL>
<LI>
<A HREF="#introduction">How <B>tolua</B> works</A></LI>

<LI>
<A HREF="#using">How to use <B>tolua</B></A></LI>

<LI>
<A HREF="#basics">Basic Concepts</A></LI>

<LI>
<A HREF="#constants">Binding constants</A></LI>

<LI>
<A HREF="#variables">Binding external variables</A></LI>

<LI>
<A HREF="#functions">Binding functions</A></LI>

<LI>
<A HREF="#structs">Binding struct fields</A></LI>

<LI>
<A HREF="#classes">Binding classes and methods</A></LI>

<LI>
<A HREF="#modules">Module definition</A></LI>

<LI>
<A HREF="#renaming">Renaming constants, variables and functions</A></LI>

<LI>
<A HREF="#additional">Storing additional fields</A></LI>

<LI>
<A HREF="#utilities">Exported utility functions</A></LI>

<LI>
<A HREF="#embedded">Embedded Lua code</A></LI>

<LI>
<A HREF="#changes-v2">Changes since v2.*</A></LI>

<LI>
<A HREF="#changes-v1">Changes since v1.*</A></LI>

<LI>
<A HREF="#credits">Credits</A></LI>

<LI>
<A HREF="#availability">Availability</A></LI>
</UL>
</UL>

<HR WIDTH="100%">
<H3>
<A NAME="introduction"></A>How tolua works</H3>
To use <B>tolua</B>, we create a <I>package file</I>, a C/C++ cleaned header
file<I>,</I> listing the constants, variables, functions, classes, and
methods we want to export to the Lua environment. Then <B>tolua</B> parses
this file and creates a C/C++ file that automatically binds the C/C++ code
to Lua. If we link the created file with our application, the specified
C/C++ code can be accessed from Lua.
<P>Let's start with some examples. If we specify as input the following
C-like header file to <B>tolua</B>:
<PRE>#define FALSE 0
#define TRUE 1

enum {&nbsp;
&nbsp;POINT = 100,&nbsp;
&nbsp;LINE,&nbsp;
&nbsp;POLYGON
}</PRE>

<PRE>Object* createObejct (int type);
void drawObject (Object* obj, double red, double green, double blue);
int isSelected (Object* obj);</PRE>
A C file that binds such a code to Lua is automatically generated. Therefore,
in Lua code, we can access the C code, writing, for instance:
<PRE>...
myLine = createObject(LINE)
...
if isSelected(myLine) == TRUE then
&nbsp; drawObject(myLine, 1.0, 0.0, 0.0);
else
&nbsp; drawObject(myLine, 1.0, 1.0, 1.0);
end
...</PRE>
Also, consider a C++-like header file:
<PRE>#define FALSE 0
#define TRUE 1</PRE>

<PRE>class Shape
{
&nbsp; void draw (void);
&nbsp; void draw (double red, double green, double blue);
&nbsp; int isSelected (void);
};</PRE>

<PRE>class Line : public Shape
{
&nbsp;Line (double x1, double y1, double x2, double y2);
&nbsp;~Line (void);
};</PRE>
If this file is used as input to <B>tolua</B>, a C++ file is automatically
generated proving access to such a code from Lua. Therefore, it would be
valid to write Lua statements like:
<PRE>...
myLine = Line:new (0,0,1,1)
...
if myLine:isSelected() == TRUE then
&nbsp;myLine:draw(1.0,0.0,0.0)
else
&nbsp;myLine:draw()
end
...
myLine:delete()
...</PRE>
The package file (usually with extension <TT>.pkg</TT>) passed to <B>tolua</B>
is not the real C/C++ header file, but a <I>cleaned </I>version of it.
For instance, the C++ methods should be public since we are accessing them
from external code, but no <TT>public: </TT>keyword appears in it. <B>tolua</B>
does not implement a complete parse to interpret C/C++ code, but it understands
a few declarations that are used to describe the features that are to be
exported to Lua. However, obtaining a cleaned header file should be a matter
of rearranging existing declaration of the real header file.
<H3>
<A NAME="using"></A>How to use toLua</H3>
<B>tolua </B>is composed by two pieces of code: an executable and a library.
The executable represents the parser that reads a package file and output
a C/C++ code that implements the binding to access the C/C++ features from
Lua. If the package file is a C++ like code (i.e., includes class definitions),
a C++ code is generated. If the cleaned header file is a C like code (i.e.,
without classes), a C code is generated. <B>tolua</B> accepts a set of
options. Running <TT>"tolua -h"</TT> displays the current accepted options.
For instance, to parse a file called <TT>myfile.pkg
</TT>generating the
binding code in <TT>myfile.c</TT>, we do:
<P><TT>tolua -o myfile.c myfile.pkg</TT>
<P>The generated code must be compiled and linked with the application
to provide the desired access from Lua. Each parsed file represents a package
being exported to Lua. By default, the package name is the input file root
name (<TT>myfile </TT>in the example). The user can specify a different
name for the package:
<P><TT>tolua -n pkgname -o myfile.c myfile.pkg</TT>
<P>The package should also be explicitly initialized. To initialize the
package from our C/C++ code, we must declare and call the initialization
function. The initialization function is defined as
<P><TT>int tolua_<I>pkgname</I>_open (void);</TT>
<P>where <I><TT>pkgname </TT></I>represents the name of the package being
bound. If we are using C++, we can opt for automatic initialization:
<P><TT>tolua -a -n pkgname -o myfile.c myfile.pkg</TT>
<P>In that case, the initialization function is automatically called. However,
if we are planning to use multiple Lua states, automatic initialization
does not work, because the order static variables are initialized in C++
is not defined.
<P>The current <B>tolua</B> version also exports a closing function, which
can be called to unbind the package.
<P><TT>void tolua_<I>pkgname</I>_close (void);</TT>
<P>Optionally, the prototype of both <TT>open</TT> and <TT>close</TT> functions
can be outputted to a header file, which name is given by the <TT>-H</TT>
option.
<P>The binding code generated by <B>tolua </B>uses a set of functions defined
in the <B>tolua </B>library. Thus, this library also has to be linked with
the application. The file <TT>tolua.h</TT> is also necessary to compile
the generated code.
<P>An application can use tolua object oriented framework (see <A HREF="#utilities">exported
utility functions</A>) without binding any package. In that case, the application
must call <B>tolua </B>initialization function (this function is called
by any package file initialization function):
<P><TT>int tolua_open (void);</TT>
<P>If multiple Lua states are to be used, after setting a Lua state, we
need to call a function to restore <B>tolua </B>internal state:
<P><TT>void tolua_restorestate (void);</TT>
<H3>
<A NAME="basics"></A>Basic Concepts</H3>
The first step in using <B>tolua</B> is to create the package file. Starting
with the real header files, we clean them by declaring the features we
want to access from Lua in a format that <B>tolua</B> can understand. The
format <B>tolua</B> understands is simple C/C++ declarations as described
below. A package file may include other package file. The general format
to do that is: <TT>$&lt;<I>include_file</I>>.</TT>
<H4>
Basic types</H4>
<B>tolua </B>automatically maps C/C++ basic types to Lua basic types. Thus,
<TT>char</TT>,
<TT>int</TT>,
<TT>float</TT>, and <TT>double </TT>are mapped to the Lua type <TT>number</TT>;<TT>
char*</TT> is mapped to <TT>string</TT>; and<TT> void*</TT> is mapped to
<TT>userdata</TT>. Types may be preceded by modifiers (<TT>unsigned</TT>,
<TT>static</TT>, <TT>short</TT>, <TT>const</TT>, etc.); however, be aware
that <B>tolua </B>ignores the modifier <TT>const</TT> if applied to basic
types. Thus, if we pass a constant basic type to Lua and then pass it back
to C/C++ code where a non constant is expected, the constant to non constant
conversion will be silently done.
<P>Functions in C/C++ can also manipulate Lua objects explicitly. Thus
<TT>lua_Object</TT>
is also considered a basic type. In this case, any Lua value matches it.
<H4>
User defined types</H4>
All other types that appear in the package file being processed are considered
user defined types. These are mapped to tagged userdata type in Lua. Lua
can only store pointers to user defined types; although, <B>tolua
</B>automatically
makes the necessary arrangement to deal with references and values. For
instance, if a function or method returns a value of user defined type,
<B>tolua
</B>allocates
a clone object when returning it to Lua and sets the garbage collection
tag method to automatically free the allocated object when no longer in
use by Lua.
<P>For user defined types, constness if preserved. Thus passing a non constant
user defined type to a function that expects constant type generates an
type mismatching error.
<H4>
<TT>NULL </TT>and <TT>nil</TT></H4>
C/C++ <TT>NULL</TT> or <TT>0 </TT>pointers are mapped to Lua
<TT>nil </TT>type;
conversely, <TT>nil </TT>may be specified wherever a C/C++ pointer is expected.
This is valid for any type: <TT>char*</TT>,
<TT>void*</TT>, and pointers
to user defined types.
<H4>
Typedefs</H4>
<B>tolua </B>also accepts simple typedef<I>'s </I>inside the package files.
Any occurrence of a type after its definition is mapped by <B>tolua
</B>to
the base type. They are useful because several packages redefine the basic
C/C++ types to their own types. For instance, one can define the type <TT>real
</TT>to
represent a <TT>double</TT>. In that case, <TT>real
</TT>can be used to
specify the variable types inside the package file interpreted by <B>tolua</B>,
but only if we include the following definition before any use of the type
<TT>real</TT>.
<P><TT>typedef double real;</TT>
<P>Otherwise, <TT>real </TT>would be interpreted as a user defined type
and would not be mapped to Lua numbers.
<H4>
Including real header files</H4>
In the package file, we must specify which are the real header files that
should be included so that the generated code can access the constants,
variables, functions, and classes we are binding. Any line in the package
file beginning with a <B>$ </B>(except $&lt;...>, $[ , and $] lines) is
insert into the generated binding C/C++ code without any change, but the
elimination of the <B>$</B> itself. We use this feature to include the
real header files. So, our package files will usually start with a set
of <B>$</B> beginning lines specifying the files that must be included,
that is, the files the package file is based on.
<PRE>/* specify the files to be included */</PRE>

<PRE>$#include &quot;header1.h&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // include first header
$#include &quot;header2.h&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // include second header</PRE>
As illustrated, <B>tolua </B>also accepts comments, using C or C++ convention,
inside the package file. Nested C-like comments can also be used.
<P>In the following sections, we describe how to specify the C/C++ code
we want to bind to Lua. The formats are simplified valid C/C++ statements.
It is very simple to convert an real C/C++ header file into a package file.
<H3>
<A NAME="constants"></A>Binding constants</H3>
To bind constants, <B>tolua </B>accepts both define's and enum's. For define's
the general format is:
<PRE><B>#define</B> <I>NAME </I>[ <I>VALUE </I>]</PRE>
The value, as showed above, is optional. If such a code is inserted inside
the file being processed, <B>tolua </B>generates a code that allows the
use of <I><TT>NAME </TT></I>as a Lua global variable that has the corresponding
C/C++ constant value. Only numeric constants are accepted.
<P>For enum's, the general format is:
<PRE><B>enum {
</B>&nbsp; <I><TT>NAME1 </TT></I>[ <B>=</B> <I>VALUE1 </I>] <B>,
</B>&nbsp; <I>NAM</I>E2 [ <B>=</B> <I>VALUE2 </I>] <B>,
</B>&nbsp; ...
&nbsp; <I>NAMEn </I>[ <B>=</B> <I>VALUEn </I>]
<B>};</B></PRE>
Similarly, <B>tolua</B> creates a set of global variables, named <I><TT>NAMEi</TT></I>,
with their corresponding values.
<H3>
<A NAME="variables"></A>Binding external variables</H3>
Global extern variables can also be exported. In the cleaned header file
they are specified as:
<PRE><TT>[</TT><B>extern</B><TT>]</TT><B> </B><I>type var</I><B>;</B></PRE>
<B>tolua</B> binds such declarations to Lua global variables. Thus, in
Lua, we can access the C/C++ variable naturally. If the variable is non
constant, we can also assign the variable a new value from Lua. Global
variables that represent arrays of value can also be bound to Lua. Arrays
can be of any type. The corresponding Lua objects for arrays are Lua tables
indexed with numeric values; however, be aware that index 1 in Lua is mapped
to index 0 in an C/C++ array. Arrays must be pre dimensioned. For instance:
<P><TT>double v[10];</TT>
<BR>&nbsp;
<H3>
<A NAME="functions"></A>Binding functions</H3>
Functions are also specified as conventional C/C++ declarations:
<PRE><I>type funcname </I><B>(</B><I>type1 par1</I>[<B>,</B> <I>type2 <TT>par2</TT></I>[<B>,.</B>..<I>typeN parN</I>]]<B>);</B></PRE>
The returned type can be <TT>void</TT>, meaning no value is returned. A
function can also have no parameter. In that case, <TT>void </TT>may be
specified in the place of the list of parameters. The parameter types must
follow the rules already posted. <B>tolua </B>creates a Lua function binding
the C/C++ function. When calling a function from Lua, the parameter types
must match the corresponding C/C++ types, otherwise, <B>tolua
</B>generates
an error and reports which parameter is wrongly specified. If a parameter
name is omitted, <B>tolua </B>names it automatically, but its type should
be a basic type or user type previously used.
<H4>
Arrays</H4>
<B>tolua </B>also deals with function or method parameters that represent
arrays of values. The nice thing about arrays is that the corresponding
Lua tables have their values updated if the C/C++ function changes the
array contents.
<P>The arrays must be pre dimensioned. For instance:
<P><TT>void func (double a[3]);</TT>
<P>is a valid function declaration for <B>tolua</B> and calling this function
from Lua would be done by, for instance:
<P><TT>p = {1.0,1.5,8.6}</TT>
<BR><TT>func (p)</TT>
<P>The array dimension need not be a constant expression; the dimension
can also be specified by any expression that can be evaluated in run time.
For instance:
<P><TT>void func (int n, int m, double image[n*m]);</TT>
<P>is also valid since the expression <TT>n*m</TT> is valid in the binding
function scope. However, be aware that <B>tolua </B>uses dynamic allocation
for binding this function, what can degrade the performance.
<P>Despite the dimension specification, it is important to know that all
arrays passed to the actual C/C++ function are in the local scope of the
binding function. So, if the C/C++ function being called needs to hold
the array pointer for later use, the binding code will <I>not </I>work
properly.
<H4>
Overloaded functions</H4>
Overloaded functions are accepted. Remember that the distinction between
two functions with the same name is made based on the parameter types that
are mapped to Lua. So, although
<P><TT>void func (int a);</TT>
<BR><TT>void func (double a);</TT>
<P>represent two different functions in C++, they are the same function
for <B>tolua</B>, because both <TT>int </TT>and <TT>double </TT>are mapped
to the same Lua type: <TT>number</TT>.
<P>Another tricky situation occurs when expecting pointers. Suppose:
<PRE>void func (char* s);
void func (void* p);
void func (Object1* ptr);
void func (Object2* prt);</PRE>
Although these four functions represent different functions in C++, a Lua
statement like:
<PRE>func(nil)</PRE>
matches all of them.
<P>It is important to know that <B>tolua </B>decides which function will
be called in run-time, trying to match each provided function. <B>tolua
</B>first
tries to call the last specified function; if it fails, <B>tolua
</B>then
tries the previous one. This process is repeated until one function matches
the calling code or the first function is reached. For that reason, the
mismatching error message, when it occurs, is based on the first function
specification. When performance is important, we can specify the most used
function as the last one, because it will be tried first.
<P><B>tolua</B> allows the use of overloaded functions in C, see <A HREF="#renaming">Renaming
</A>for
details.
<H4>
Default parameter values</H4>
The last function parameters can have associated default values. In that
case, if the function is called with fewer parameters, the default values
are assumed. The format to specify the default values is the same as the
one used in C++ code:
<P><TT><I>type funcname </I><B>(</B><I>...</I><B>,</B><I> typeN-1 parN-1
[= valueN-1]<B>,</B> typeN parN [= valueN]</I><B>);</B></TT>
<P><B>toLua </B>implements this feature without using any C++ mechanism;
so, it can be used also to bind C functions.
<P>We can also specify default values for the elements of an array (there
is no way to specify a default value for the array itself, though). For
instance:
<P><TT>void func (int a[5]=0);</TT>
<P>sets the default element values to zero, thus the function can be called
from Lua with an uninitialized table.
<P>For Lua object types (<TT>lua_Object</TT>), <B>tolua </B>defines a constant
that can be used to specify <TT>nil </TT>as default value:
<P><TT>void func (lua_Object lo = TOLUA_NIL);</TT>
<H4>
Multiple returned values</H4>
In Lua, a function may return any number of values. <B>tolua </B>uses this
feature to simulate values passed by reference. If a function parameter
is specified as a pointer to or reference of a basic type or a pointer
to or reference of a pointer to an user defined type, <B>tolua </B>accepts
the corresponding type as input and returns, besides the conventional function
returned value, if any, the updated parameter value.
<P>For instance, consider a C function that swaps two values:
<P><TT>void swap (double* x, double* y);</TT>
<P>or
<P><TT>void swap (double&amp; x, double&amp; y);</TT>
<P>If such a function is declared in the package file, <B>tolua </B>binds
it as a function receiving two numbers as input and returning two numbers.
So, a valid Lua code would be:
<P><TT>x,y = swap(x,y)</TT>
<P>If the input values are not used, the use of default parameter value
allows calling the function from Lua without specifying them:
<P><TT>void getBox (double* xmin=0, double* xmax=0, double* ymin=0, double*
ymax=0);</TT>
<P>In Lua:
<P><TT>xmin, xmax, ymin, ymax = getBox()</TT>
<P>With user defined types, we would have for instance:
<P><TT>void update (Point** p);</TT>
<P>or
<P><TT>void update (Point*&amp; p);</TT>
<H3>
<A NAME="structs"></A>Binding struct fields</H3>
User defined types are nicely bound by <B>tolua</B>. For each variable
or function type that does not correspond to a basic type, <B>tolua </B>automatically
creates a tagged userdata to represent the C/C++ type. If the type corresponds
to a struct, the struct fields can be directly accessed from Lua, indexing
a variable that holds an object of such a type. In C code, these types
are commonly defined using typedef's:
<PRE><B>typedef struct [name]</B><I> </I><B>{
</B>&nbsp;&nbsp; <I>type1 fieldname1</I><B>;
</B>&nbsp;&nbsp; <I>type2 fieldname2</I><B>;
</B>&nbsp;&nbsp; ...
&nbsp;&nbsp; <I>typeN fieldnameN</I><B>;
} </B><I>typename</I><B>;</B></PRE>
If such a code is inserted in the package file being processed, <B>tolua
</B>allows
any variable that holds an object of type <I><TT>typename </TT></I>to access
any listed field indexing the variable by the field name. For instance,
if <TT>var </TT>holds a such object, <I><TT>var.fieldnamei</TT></I> accesses
the field named <I><TT>fieldnamei</TT></I>.
<P>Fields that represent arrays of values can also be mapped:
<P><TT>typedef struct {</TT>
<BR><TT>&nbsp; int x[10];</TT>
<BR><TT>&nbsp; int y[10];</TT>
<BR><TT>} Example;</TT>
<BR>&nbsp;
<H3>
<A NAME="classes"></A>Binding classes and methods</H3>
C++ class definitions are also supported by <B>tolua</B>. Actually, the
<B>tolua
</B>deals
with single inheritance and polymorphism in a natural way. The subsections
below describe what can be exported by a class definition.
<H4>
Specifying inheritance</H4>
If <TT>var </TT>is a Lua variable that holds an object of a derived class,
<TT>var
</TT>can
be used wherever its base class type is expected and <TT>var
</TT>can access
any method of its base class. For this mechanism to take effect, we must
indicate that the derived class actually inherits the base class. This
is done in the conventional way:
<PRE><B>class </B><I>classname </I><B>: public</B> <I>basename
</I><B>{</B></PRE>

<PRE>&nbsp;/* class definition */</PRE>

<PRE><B>};</B></PRE>

<H4>
Specifying exported members and methods</H4>
As for struct fields, class fields, static or not, can be exported. Class
methods and class static methods can also be exported. Of course, they
must be declared as public in the actual C++ code (although the
<TT>public:
</TT>keyword
may not appear in the package files).
<P>For each bound class, <B>tolua </B>creates a Lua table and stores it
at a global variable which name is the name of the C++ class. Static exported
fields are accessed by indexing this table with the field names (similar
to struct fields). Non static exported fields are accessed by indexing
the variable that holds the object. Class methods follow the format of
the function declaration showed above. They can be accessed from Lua code
using the conventional way Lua uses to call methods, applied of course
to a variable that holds the appropriate object or to the class table,
for static methods.
<P>There are a few special methods that are also supported by <B>tolua</B>.
Constructors are called as static methods, named <TT>new</TT>. Destructors
are called as a conventional method called <TT>delete</TT>.
<P>Note that <B>tolua </B>does support overload. This applies even for
constructors. Also note that the <TT>virtual </TT>keyword has no effect
in the package file.
<P>The following code exemplifies class definitions that can be interpreted
by <B>tolua</B>.
<PRE>class Point {
&nbsp;&nbsp; static int n;&nbsp;&nbsp;&nbsp; // represents the total number of created Points

&nbsp;&nbsp; double x;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // represents the x coordinate
&nbsp;&nbsp; double y;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // represents the y coordinate</PRE>

<PRE>&nbsp;&nbsp; static char* className (void);&nbsp;&nbsp; // returns the name of the class</PRE>

<PRE>&nbsp;&nbsp; Point (void);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // constructor 1
&nbsp;&nbsp; Point (double px, double py);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // constructor 2
&nbsp;&nbsp; ~Point (void);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // destructor</PRE>

<PRE>&nbsp;&nbsp; Point add (Point&amp; other);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // add points, returning another one
};</PRE>

<PRE>class ColorPoint : public Color {
&nbsp;&nbsp; int red;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // red color component [0 - 255]
&nbsp;&nbsp; int green;&nbsp;&nbsp;&nbsp; // green color component [0 - 255]
&nbsp;&nbsp; int blue;&nbsp;&nbsp;&nbsp;&nbsp; // blue color component [0 - 255]</PRE>

<PRE>&nbsp;&nbsp; ColorPoint (double px, double py, int r, int g, int b);
};</PRE>
If this segment of code is processed by <B>tolua</B>, we would be able
to write the following Lua statements:
<PRE>p1 = Point:new(0.0,1.0)
p2 = ColorPoint:new(1.5,2.2,0,0,255)
print(Point.n)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- would print 2
p3 = p1:add(p2)
print(p3.x,p3.y)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- would print 1.5 and 3.2
print(p2.red,p2.green,p2.blue)&nbsp;&nbsp;&nbsp;&nbsp; -- would print 0, 0, and 255
print(
p1:delete()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- call destructor
p2:delete()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- call destructor</PRE>
Note that we can only explicitly delete objects that we explicitly create.
In the example above, the point <TT>p3</TT> will be garbage-collected by
<B>tolua
</B>automatically;
we cannot delete it.
<P>Of course, we need to specify only the methods and members we want to
access from Lua. Sometimes, it will be necessary to declare a class with
no member or method just for the sake of not breaking a chain of inheritances.
<H4>
Overloaded operators</H4>
<B>tolua </B>automatically binds the following binary operators:
<UL>
<PRE>operator+&nbsp;&nbsp; operator-&nbsp;&nbsp; operator*&nbsp;&nbsp; operator/&nbsp;
operator&lt;&nbsp;&nbsp; operator&gt;&nbsp;&nbsp; operator&lt;=&nbsp; operator&gt;=</PRE>
</UL>
For the relational operators, <B>toLua </B>also automatically converts
a returned <TT>0</TT> value into <TT>nil</TT>, so <I>false </I>in C becomes
<I>false
</I>in
Lua.
<P>As an example, suppose that in the code above, instead of having:
<PRE>&nbsp;&nbsp; Point add (Point&amp; other);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // add points, returning another one</PRE>
we had:
<PRE>&nbsp;&nbsp; Point operator+ (Point&amp; other);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // add points, returning another one</PRE>
In that case, in Lua, we could simply write:
<PRE>p3 = p1 + p2</PRE>
The indexing operator (<TT>operator[]</TT>) when receiving a numeric parameter
can also be exported to Lua. In this case, <B>tolua </B>accepts reference
as returned value, even for basic types. Then if a reference is returned,
from Lua, the programmer can either get or set the value. If the returned
value is not a reference, the programmer can only get the value. An example
may clarify: suppose we have a vector class and bind the following operator:
<PRE>&nbsp;&nbsp; double&amp; operator[] (int index);</PRE>
In this case, in Lua, we would be able to write: <TT>value = myVector[i]</TT>
and also <TT>myVector[i] = value</TT>, what updates the C++ object. However,
if the bound operator was:
<PRE>&nbsp;&nbsp; double operator[] (int index);</PRE>
we would only be able to write: <TT>value = myVector[i]</TT>.
<P>Free functions (i.e., not class members) that overload operators are
not supported.
<H3>
<A NAME="modules"></A>Module definition</H3>
<B>tolua </B>allows us to group constants, variables, and functions in
a module. The module itself is mapped to a table in Lua, and its constants,
variables, and functions are mapped to fields in that table. The general
format to specify a module is:
<P><TT><B>module</B> name</TT>
<BR><B><TT>{</TT></B>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ... // constant, variable, and function
declarations</TT>
<BR><B><TT>}</TT></B>
<P>Thus, if we bound the following module declaration:
<P><TT>module mod</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;#define N</TT>
<BR><TT>&nbsp;extern int var;</TT>
<BR><TT>&nbsp;int func (...):</TT>
<BR><TT>}</TT>
<P>In Lua we would be able to access such features by indexing the module:
<TT>mod.N</TT>,
<TT>mod.var</TT>,
<TT>mod.func</TT>.
<H3>
<A NAME="renaming"></A>Renaming constants, variables and functions</H3>
When exporting constants, variable, and functions (members of a class or
not), we can rename them, such that they will be bound with a different
name from their C/C++ counterparts. To do that, we write the name they
will be referenced in Lua after the character <TT>@</TT>. For instance:
<P><TT>extern int cvar @ lvar;</TT>
<P><TT>#define CNAME @ LNAME</TT>
<P><TT>enum {</TT>
<BR><TT>&nbsp; CITEM1 @ LITEM1,</TT>
<BR><TT>&nbsp; CITEM2 @ LITEM2,</TT>
<BR><TT>&nbsp; ...</TT>
<BR><TT>};</TT>
<P><TT>void cfunc @ lfunc (...);</TT>
<P><TT>class T</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;&nbsp; double cfield @ lfield;</TT>
<BR><TT>&nbsp;&nbsp; void cmeth @ lmeth (...);</TT>
<BR><TT>&nbsp;&nbsp; ...</TT>
<BR><TT>};</TT>
<P>In such a case, the global variable <TT>cvar </TT>would be identified
in Lua by <TT>lvar</TT>, the constant <TT>CNAME </TT>by <TT>LNAME</TT>,
and so on. Note that class cannot be renamed, because they represent types
in C.
<P>This renaming feature allows function overload in C, because we can
choose to export two different C functions with a same Lua name:
<P><TT>void glVertex3d @ glVertex (double x, double y, double z=0.0);</TT>
<BR><TT>void glVertexdv @ glVertex (double v[3]=0.0);</TT>
<H3>
<A NAME="additional"></A>Storing additional fields</H3>
Finally, it is important to know that even though the variables that hold
C/C++ objects are actually tagged userdata for Lua,<B> tolua</B> creates
a mechanism that allows us to store any additional field attached to these
objects. That is, these objects can be seen as conventional Lua tables.
<PRE>obj = <I>ClassName</I>:new()</PRE>

<PRE>obj.myfield = 1&nbsp; -- even though &quot;myfield&quot; does not represent a field of ClassName</PRE>
Such a construction is possible because, if needed, <B>tolua </B>automatically
creates a Lua table and associates it with the object. So that, the object
can store additional fields not mapped to C/C++, but actually stored in
the conjugate table. The Lua programmer accesses the C/C++ features and
these additional fields in an uniform way. Note that, in fact, these additional
fields overwrite C/C++ fields or methods when the names are the same.
<H3>
<A NAME="utilities"></A>Exported utility functions</H3>
<B>tolua </B>uses itself to export some utility functions to Lua, including
its object-oriented framework. The package file used by <B>tolua </B>is
shown below:
<P><TT>module tolua</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;void tolua_using @ using (lua_Table module);</TT>
<BR><TT>&nbsp;char* tolua_type @ type (lua_Object lo);</TT>
<BR><TT>&nbsp;void tolua_foreach @ foreach (lua_Object lo, lua_Function
f);</TT>
<BR><TT>&nbsp;void tolua_class @ class (lua_Table derived, lua_Table base=TOLUA_NIL);</TT>
<BR><TT>&nbsp;void tolua_instance @ instance (lua_Table instance, lua_Table
classobj);</TT>
<BR><TT>&nbsp;lua_Object tolua_base @ base (lua_Object lo);</TT>
<BR><TT>}</TT>
<H4>
tolua.using (<I>table</I>)</H4>
This functions receives a table and maps all its fields to the global environment.
Thus we can map an entire module and access its features without the module
prefix. For instance, if in our Lua code we do:
<P><TT>tolua.using(tolua)</TT>
<P>all <B>tolua </B>utility functions are mapped to the global environment.
<H4>
tolua.type (<I>var</I>)</H4>
Returns a string representing the object type. For instance, <TT>tolua.type(tolua)</TT>
returns the string <TT>generic module</TT> and <TT>tolua.type(tolua.type)</TT>
returns <TT>cfunction</TT>. Similarly, if <TT>var </TT>is a variable holding
a user defined type <TT>T</TT>, <TT>tolua.type(var)</TT> would return
<TT>const
T</TT> or <TT>T</TT>, depending whether it is a constant reference.
<H4>
tolua.tag (<I>"type"</I>)</H4>
Returns type corresponding tag number.
<H4>
tolua.foreach (<I>object</I>)</H4>
Allows us to traverse the conjugate table of an user defined instance.
If applied to conventional table, it has a similar behavior as the Lua
built-in <TT>foreach </TT>function. The difference is that this function
filters all fields starting with a dot, not passing them to the provided
callback function. This filter is need because <B>tolua </B>adds "hidden"
fields to the tables it manipulates, and all its "hidden" fields start
with a dot.
<H4>
tolua.cast (<I>object, "typename"</I>)</H4>
Returns the object "casted" to the given type. The object must represent
an user type, otherwise the function returns <B><TT>nil</TT></B>.
<H4>
tolua.takeownership (<I>object</I>)</H4>
Asks <B>tolua</B> to take the ownership of the given object. This means
the C/C++ object will be freed/ destructed when garbage-collected by Lua.&nbsp;
The object must represent an user type, otherwise an execution error is
generated.
<H4>
tolua.class (<I>table</I>, <I>base=nil</I>)</H4>
Creates a class by setting the appropriate tag methods to the given table.
The created class can inherit from a base class, previously created.
<H4>
tolua.instance (<I>table</I>, <I>class</I>)</H4>
Sets the given table to be an instance of the given class. This and the
previous utility functions allow object-oriented programming in Lua. As
an example consider:
<P><TT>-- define a Point class</TT>
<BR><TT>classPoint = { x=0, y=0 }</TT>
<BR><TT>tolua.class(classPoint) -- set as a class</TT>
<P><TT>-- define print method</TT>
<BR><TT>function classPoint:print ()</TT>
<BR><TT>&nbsp;&nbsp; print(self.x,self.y)</TT>
<BR><TT>end</TT>
<P><TT>-- define add method</TT>
<BR><TT>function classPoint:add (p2)</TT>
<BR><TT>&nbsp;&nbsp; return Point{x=self.x+p2.x,y=self.y+p2.y}</TT>
<BR><TT>end</TT>
<P><TT>-- define a Point constructor</TT>
<BR><TT>function Point (p)</TT>
<BR><TT>&nbsp;&nbsp; tolua.instance(p,classPoint) -- set as an instance
of classPoint</TT>
<BR><TT>return p end</TT>
<P><TT>-- define a Color Point class</TT>
<BR><TT>classColorPoint = { color = 'black' }</TT>
<BR><TT>tolua.class(classColorPoint,classPoint) -- set as class inheriting
from classPoint</TT>
<P><TT>-- define class methods</TT>
<BR><TT>function classColorPoint:print ()</TT>
<BR><TT>&nbsp;&nbsp; print(self.x,self.y,self.color)</TT>
<BR><TT>end</TT>
<P><TT>-- define Color Point constructor</TT>
<BR><TT>function ColorPoint (p)</TT>
<BR><TT>&nbsp;&nbsp; tolua.instance(p,classColorPoint) -- set as an instance
of classColorPoint</TT>
<BR><TT>&nbsp;&nbsp; return p</TT>
<BR><TT>end</TT>
<P><TT>-- Some valid codes would then be</TT>
<BR><TT>p = Point{x=1}</TT>
<BR><TT>q = ColorPoint{x=2,y=3,color=2}</TT>
<BR><TT>r = p:add(q)</TT>
<BR><TT>r:print() --> would print "3 3"</TT>
<BR>&nbsp;
<H3>
<A NAME="embedded"></A>Embedded Lua code</H3>
<B>tolua</B> allows us to embed Lua code in the C/C++ generated code. To
do that, it compiles the specified Lua code and creates a C constant string,
storing the corresponding bytecodes, in the generated code.&nbsp; When
the package is opened, such a string is executed. The format to embed Lua
code is:
<P><B><TT>$[</TT></B>
<P><I><TT>embedded Lua code</TT></I>
<BR><I><TT>...</TT></I>
<P><B><TT>$]</TT></B>
<P>As an example consider the following .pkg excerpt:
<P><TT>/* Bind a Point class */</TT>
<BR><TT>class Point</TT>
<BR><TT>{</TT>
<BR><TT>&nbsp;Point (int x, int y);</TT>
<BR><TT>&nbsp;~Point ();</TT>
<BR><TT>&nbsp;void print ();</TT>
<BR><TT>&nbsp;...</TT>
<BR><TT>} CPoint;</TT>
<P><TT>$[</TT>
<P><TT>-- Create a Point constructor</TT>
<BR><TT>function Point (self)</TT>
<BR><TT>&nbsp;local cobj = CPoint:new(self.x or 0, self.y or 0)</TT>
<BR><TT>&nbsp;tolua.takeownership(cobj)</TT>
<BR><TT>&nbsp;return cobj</TT>
<BR><TT>end</TT>
<P><TT>$]</TT>
<P>Binding such a code would allow us to write the following Lua code:
<P><TT>p = Point{ x=2, y=3 }</TT>
<BR><TT>p:print()</TT>
<BR><TT>...</TT>
<BR>&nbsp;
<H3>
<A NAME="changes-v30"></A>Changes since v. 3.0</H3>

<ul>

<LI>
Support for binding arrays as variables and struct/class fields;</LI>

<LI>
Support for embedding Lua code into the generated binding code;</LI>

<LI>
New utility functions: <I>cast</I> and <I>takeownership</I>;</LI>

<LI>
Option to create the corresponding header file of the binding code;</LI>

<LI>
New "close" package function;</LI>

<LI>
Fixed bug on cloning objects in C++;</LI>

<LI>
Fixed bug on enum and struct parsing;</LI>

<H3>
<A NAME="changes-v2"></A>Changes since v. 2.0</H3>

<LI>
There is a new executable parser;</LI>

<LI>
Support for multiple Lua states is provided;</LI>

<LI>
Support for module definition is provided;</LI>

<LI>
Global variables is now directly bound to Lua global variables;</LI>

<LI>
Constness of user defined types is preserved in Lua;</LI>

<LI>
Support for multiple returned values from C/C++ is provided (simulating
parameters passed by reference);</LI>

<LI>
Constants, variables, and functions bound to Lua can have different names
from their C/C++ counterparts;</LI>

<LI>
Object-oriented framework (and other utility functions) used in <B>tolua
</B>is
now exported for Lua programmers;</LI>

<H4>
Incompatibilities</H4>
Lua code based on <B>tolua</B> v2.* should run with no change on <B>tolua
</B>v3.0.
Although, it may be necessary to change the .pkg file in order to get the
same behavior. The following incompatibilities exist:
<UL>
<LI>
Parameters defined as pointer to basic types are no longer converted to
arrays of dimension one; they are now considered parameters passed by reference.</LI>

<LI>
Automatic initialization for C++ code must be explicitly requested when
using the new parser;</LI>

<LI>
Global variables are no longer mapped to a table; the definition of a module
including the global variables may be used to simulate the old behavior;</LI>

<LI>
The initialization function is no longer toLua_<I>package</I>_open but
tolua_<I>package</I>_open, without the capital letter (sorry!).</LI>
</UL>

<H3>
<A NAME="changes-v1"></A>Changes since v. 1.*</H3>

<LI>
The binding code should run much faster;</LI>

<LI>
The <I>cleaned header file </I>extension should now be <TT>.pkg</TT> instead
of <TT>.L</TT>;</LI>

<LI>
Type modifiers is now accepted (though the current version ignores
<TT>const</TT>'s);</LI>

<LI>
Returning object by value is accepted and memory allocation is controlled
by Lua garbage collection;</LI>

<LI>
Overloaded functions/methods are accepted;</LI>

<LI>
Parameters with default values are accepted;</LI>

<LI>
Some overloaded operators are automatically bound.</LI>

<H3>
<A NAME="credits"></A>Credits</H3>
Luiz Henrique de Figueiredo had the idea of creating a tool to automatically
bind C code to Lua. L.H.F. wrote the very first version of such a tool
(that bound C functions, variables, and constants) in <I>awk</I>. At that
time, I was only responsible for the C code that supported the generated
binding code.
<BR>&nbsp;
<H3>
<A NAME="availability"></A><B>Availability</B></H3>
<B>tolua </B>is freely available by <A HREF="ftp://ftp.tecgraf.puc-rio.br/pub/users/celes/tolua/tolua.tar.gz">ftp</A>.
The software provided hereunder is on an "as is" basis, and the author
has no obligation to provide maintenance, support, updates, enhancements,
or modifications.
<P>
<HR WIDTH="100%">Software and page created and maintained by <A HREF="http://www.tecgraf.puc-rio.br/~celes/">Waldemar
Celes</A> .
<BR>Last update: Jul 1999<BODT>
</BODY>
</HTML>
